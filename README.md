Netflow коллектор.

Функции:
- Сбор потока
- Агрегация по ip-подсетям, или id абонентов
- Агрегация top'ов (а-ля bstatd)
- Интеграция с traf-reporter и bstatd от CarbonSoft
- Интеграция с bstatd будет в экспорте уже разобранных данных в формате хранилища bstatd
- Планируется полная замена bstatd
- Real-time мониторинг (скорость) по абонентам и (нагрузка каналов) по брасам
- (!) расчет кол-ва и объемов пакетов nf в сек/мин/час
- TOP100 статистику можно хранить в файлах по юзерам со структурой:
{dest_ip, pkg_count, pkg_size, pkg_next}
Где pkg_next - указатель на следующую структуру (если dest_ip в нем тотже, то pkg_count, pkg_size суммируются (защита от переполнения))
Мб отдельно файл с индексом
Отдельно запускается задача по сортировке каким-нибудь пузырьком, т.к порядок меняется редко



Идея функции опроса большого количества процессов:
Процесс Х запускает запрос, процесс У - следит за ними, ххх - один из процессов, которые нужно опросить.

В У есть функция call_many(), которую вызывает Х, она делает:
1. устанавливает монитор на У (если У сдох - завершить прием сообщений (как поступить с теми, которые все таки дойдут?))
2. make_ref()
3. посылает У синхронное сообщение {call_many, Ref, function, args}

    В У:
    1. установить монитор на Х (чтобы грохнуть временные данные если процесс сдохнет и не сможет завершить контракт)
    2. берет список всех детей, сохраняет вместе с пидом Х, Ref. 
    3. отсылает всем детям асинхронно {call, Ref, X_Pid, function, args}
    4. отвечает {ok, count(срез детей)}
    
    В ххх:
    1. принять запрос, отдать ответ в Х_Pid

4. возвращаем функцию, которая занимается приемом ответа

Контракт:
Х:
1. принимает все сообщения от ххх, деинкрементируя count, пока он не станет 0
2. когда он станет 0 - отсылаем в У сообщение {done_call_many, Ref}, он очищает все временные данные по нему
3. если ребенок сдох: У это поймает, проверит что пид ребенка был в запросе у Х и отошлет ему инфу, что он сдох, Х сделает деинкремент
4. если Х сдох - У очищает данные по нему
5. если У сдох:
    5.1. дочитываем оставшиеся сообщения, пока есть (в теории, супервизор У убъет детей, но это в идеале - может течь память)
    5.2. кидаем ошибку, дохнем, сообщения даже если придут - ящика не будет - сообщение дропнется